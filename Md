Para corregir los puntos identificados y cumplir en mayor medida con los requisitos del enunciado, aquí te detallo las adiciones y modificaciones necesarias en tu código:
1. Corrección de Redirección para Rutas Protegidas y Autenticadas
[cite_start]Objetivo: Redirigir a una página "not-found" cuando un usuario no autenticado intente acceder a una ruta privada, y redirigir al dashboard si un usuario autenticado intenta acceder a /login o /register.
Archivo a modificar: router.js
Cambios propuestos:
// router.js
import { auth } from './js/auth';
import { showLogin } from "./views/login";
import { showStartingPage } from "./views/pagestart";
import { showRegister } from "./views/register";
import { showDashboard, showCourses, showCreateCourse, showEditCourse } from "./views/dashboard";

// IMPORTAR AQUI LA FUNCION DE LA VISTA 404 SI ESTA EN UN ARCHIVO SEPARADO
// Por ejemplo: import { renderNotFoundPage } from "./views/not-found";

export function renderNotFound() {
    document.getElementById('app').innerHTML = `<h1>404 Error, Page not found</h1>`;
}

// Puedes tener una función separada para la vista de "Acceso Denegado" o usar renderNotFound()
export function renderAccessDenied() {
    document.getElementById('app').innerHTML = `<h1>Access Denied: You do not have permission to view this page.</h1>`;
}

function redirectToLogin() {
    history.pushState(null, null, "/login");
    router();
}

const routes = {
    "/": {
        showView: showStartingPage,
        private: false
    },
    "/login": {
        showView: showLogin,
        private: false // Es una vista pública, pero tendrá lógica de redirección si ya está logeado
    },
    "/register": {
        showView: showRegister,
        private: false // Es una vista pública, pero tendrá lógica de redirección si ya está logeado
    },
    "/dashboard": {
        showView: showDashboard,
        private: true
    },
    // Modificar rutas para que coincidan con el enunciado si se usara el prefijo '/dashboard/events'
    "/courses": { // Mantengo /courses como la tenías, ajusta si quieres /dashboard/events
        showView: showCourses,
        private: true
    },
    "/courses/create": { // Mantengo /courses/create, ajusta si quieres /dashboard/events/create
        showView: showCreateCourse,
        private: true,
        roles: ['admin']
    },
};

export async function router() {
    const path = window.location.pathname;
    const user = auth.getUser();

    let currentRoute = null;
    let isDynamicRoute = false;
    let dynamicId = null; // Para almacenar el ID de rutas dinámicas

    // 1. Lógica de redirección para usuarios autenticados que intentan acceder a /login o /register
    if (user && (path === "/login" || path === "/register")) {
        history.pushState(null, null, "/dashboard"); // Redirige al dashboard
        router();
        return; // Detiene la ejecución del router actual
    }

    // 2. Intentar encontrar una ruta estática
    if (routes[path]) {
        currentRoute = routes[path];
    } else {
        // 3. Intentar encontrar rutas dinámicas
        const pathSegments = path.split('/').filter(segment => segment !== '');

        // Ejemplo para /courses/edit/:id
        // Si el enunciado fuera /dashboard/events/edit/:id, los segmentos serían diferentes
        if (pathSegments.length === 3 &&
            pathSegments[0] === 'courses' && // O 'dashboard'
            pathSegments[1] === 'edit' &&    // O 'events'
            !isNaN(pathSegments[2])) {       // Asegura que el último segmento sea un ID numérico
            currentRoute = {
                showView: showEditCourse,
                private: true,
                roles: ['admin']
            };
            isDynamicRoute = true;
            dynamicId = pathSegments[2]; // Captura el ID para pasarlo a la vista si es necesario
        }
        // CONSIDERACIÓN: Si quieres /dashboard/events/create, mueve esa ruta dinámica aquí
        // o ajusta el objeto `routes` para que sea `/dashboard/events/create` en lugar de `/courses/create`
    }

    // Si no se encontró ninguna ruta
    if (!currentRoute) {
        renderNotFound(); // Usa la función 404 para rutas no definidas
        return;
    }

    // --- Lógica de Protección de Rutas ---
    // Si la ruta es privada y no hay usuario, redirige a not-found (como pide el enunciado para rutas protegidas)
    // NOTA: El enunciado dice "not-found.js" para rutas protegidas sin autenticación.
    // Si prefieres redirigir al login (lo que tienes ahora y es más común), mantén redirectToLogin().
    if (currentRoute.private && !user) {
        // history.pushState(null, null, "/not-found"); // Redirige a una ruta 404/denegado
        // router();
        // O simplemente:
        renderNotFound(); // O renderAccessDenied() si tienes una vista específica
        return;
    }

    // Si la ruta requiere roles específicos
    if (currentRoute.roles && (!user || !currentRoute.roles.includes(user.role))) {
        // alert('You do not have permission to access this page.'); // Ya no es una alerta
        // history.pushState(null, null, "/dashboard"); // No redirigir al dashboard, sino a un acceso denegado o 404
        // router();
        renderAccessDenied(); // O renderNotFound()
        return;
    }

    // --- Renderizar la vista ---
    // Pasa el ID dinámico a la vista si es una ruta dinámica
    if (isDynamicRoute && dynamicId) {
        await currentRoute.showView(dynamicId); // Asume que showEditCourse puede aceptar un ID
    } else {
        await currentRoute.showView();
    }

    // --- Ejecutar afterRender si existe y es una función ---
    if (typeof currentRoute.afterRender === "function") {
        currentRoute.afterRender();
    }
}

Notas importantes para esta sección:
 * [cite_start]He modificado la lógica para que las rutas protegidas, cuando se acceden sin autenticación, muestren un "404 Error" o un "Access Denied" en lugar de redirigir a /login, como lo pide el requisito. Puedes elegir entre renderNotFound() o crear una renderAccessDenied() específica.
 * [cite_start]He agregado la lógica para redirigir a /dashboard si un usuario autenticado intenta ir a /login o /register.
 * [cite_start]Para las rutas de "Crear Eventos" y "Editar Eventos", tu enunciado usa /dashboard/events/create y /dashboard/events/edit. Tu código actual usa /courses/create y /courses/edit. He mantenido tu implementación para no romperla, pero ten en cuenta que, para cumplir exactamente con el enunciado, deberías ajustar las rutas en el objeto routes y en la lógica de showEditCourse para que coincidan con /dashboard/events/....
2. Visualización de Registros de Visitantes
[cite_start]Objetivo: Permitir que los visitantes visualicen los eventos en los que están registrados en la misma vista de cursos.
Archivo a modificar: views/dashboard.js (dentro de showCourses())
Cambios propuestos en showCourses():
// ... dentro de showCourses()

export async function showCourses() {
    const user = auth.getUser();
    if (!user) {
        history.pushState(null, null, "/login");
        router();
        return;
    }

    const courses = await window.api.get('/courses');

    // Modificación para resaltar los cursos en los que el usuario ya está inscrito
    const coursesHtml = courses.map(c => {
        const isEnrolled = c.enrolled && c.enrolled.includes(user.email);
        const enrollButton = user.role === 'student' && !isEnrolled && c.enrolled.length < c.capacity
            ? `<button class="enroll-btn" data-id="${c.id}">Enroll</button>`
            : (isEnrolled ? `<span style="color: green; font-weight: bold;">(Enrolled)</span>` : `<span style="color: orange; font-weight: bold;">(Full)</span>`); // Muestra "Full" si está lleno y no está inscrito
        const editButton = user.role === 'admin'
            ? `<button onclick="navigateTo('/courses/edit/${c.id}')">Edit</button>` // Ajusta a /dashboard/events/edit si cambias la ruta
            : '';

        return `
            <li ${isEnrolled ? 'style="background-color: #e6ffe6; border: 1px solid #ccebcc;"' : ''}>
                ${c.title || 'No title'} (${c.capacity || 0} slots) — Instructor: ${c.instructor || 'N/A'}
                ${editButton}
                ${user.role === 'student' ? enrollButton : ''}
            </li>`;
    }).join('');

    document.getElementById('app').innerHTML = `
        <h2>Available Courses</h2>
        <ul>${coursesHtml}</ul>`;

    if (user.role === 'student') {
        document.querySelectorAll('.enroll-btn').forEach(btn => {
            btn.onclick = async () => {
                const courseId = btn.dataset.id;
                const course = await window.api.get('/courses/' + courseId);

                if (!course.enrolled) course.enrolled = [];

                if (course.enrolled.includes(user.email)) {
                    alert('You are already enrolled in this course.');
                    return;
                }

                if (course.enrolled.length >= course.capacity) {
                    alert('This course is full.');
                    return;
                }

                course.enrolled.push(user.email);
                course.capacity = course.capacity - 1; // Decrementa la capacidad

                await window.api.put('/courses/' + courseId, course);
                alert('Enrollment successful!');
                showCourses(); // recargar lista para reflejar el cambio
            };
        });
    }
}

Explicación:
 * He añadido lógica dentro del map para verificar si isEnrolled (si el usuario actual está en la lista enrolled del curso).
 * Si el usuario es estudiante y ya está inscrito, se mostrará (Enrolled) en lugar del botón "Enroll".
 * Si el curso está lleno y el usuario no está inscrito, se mostrará (Full).
 * Se añade un estilo (background-color, border) a los <li> para los cursos en los que el usuario ya está inscrito, haciéndolos visualmente distinguibles.
3. Ajuste de Rutas de Vistas (Opcional pero recomendado para coincidir con el enunciado)
[cite_start]Objetivo: Asegurar que los paths de las vistas de eventos coincidan exactamente con lo solicitado en el enunciado (/dashboard/events/create y /dashboard/events/edit).
Archivos a modificar: router.js y views/dashboard.js (específicamente en showCourses y showDashboard).
Cambios propuestos:
En router.js:
// ... (parte superior del archivo)

const routes = {
    "/": {
        showView: showStartingPage,
        private: false
    },
    "/login": {
        showView: showLogin,
        private: false
    },
    "/register": {
        showView: showRegister,
        private: false
    },
    "/dashboard": {
        showView: showDashboard,
        private: true
    },
    "/dashboard/events": { // Cambiado de /courses
        showView: showCourses,
        private: true
    },
    "/dashboard/events/create": { // Cambiado de /courses/create
        showView: showCreateCourse,
        private: true,
        roles: ['admin']
    },
    // Nota: Las rutas dinámicas como "/dashboard/events/edit/:id" se manejan en la lógica del 'router'
};

export async function router() {
    const path = window.location.pathname;
    const user = auth.getUser();

    // ... (lógica de redirección para /login y /register si el usuario está autenticado)

    let currentRoute = null;
    let isDynamicRoute = false;
    let dynamicId = null;

    if (routes[path]) {
        currentRoute = routes[path];
    } else {
        const pathSegments = path.split('/').filter(segment => segment !== '');

        // Ejemplo para /dashboard/events/edit/:id
        if (pathSegments.length === 4 && // Ahora son 4 segmentos: dashboard/events/edit/ID
            pathSegments[0] === 'dashboard' &&
            pathSegments[1] === 'events' &&
            pathSegments[2] === 'edit' &&
            !isNaN(pathSegments[3])) {
            currentRoute = {
                showView: showEditCourse,
                private: true,
                roles: ['admin']
            };
            isDynamicRoute = true;
            dynamicId = pathSegments[3]; // El ID ahora es el cuarto segmento
        }
    }
    // ... (el resto del router permanece igual)
}

En views/dashboard.js (dentro de showDashboard() y showCourses()):
// Dentro de showDashboard()
document.getElementById('app').innerHTML = `
    <h2>Welcome, ${user.name} (${user.role})</h2>
    <button id="logout-btn">Logout</button>
    <nav>
        <a href="/dashboard/events" data-link>View courses</a> // Cambiado de /courses
        ${user.role === 'admin' ? `<a href="/dashboard/events/create" data-link>Create course</a>` : ''} // Cambiado de /courses/create
    </nav>`;

// Dentro de showCourses()
// En la parte del botón de "Edit":
// ...
const editButton = user.role === 'admin'
    ? `<button onclick="navigateTo('/dashboard/events/edit/${c.id}')">Edit</button>` // Cambiado de /courses/edit
    : '';

// Dentro de showCreateCourse() (al guardar y redirigir)
await window.api.post('/courses', data);
history.pushState(null, null, '/dashboard/events'); // Cambiado de /courses
router();

// Dentro de showEditCourse() (al guardar y redirigir)
await window.api.put('/courses/' + courseId, updated);
history.pushState(null, null, '/dashboard/events'); // Cambiado de /courses
router();

Consideraciones Adicionales para los Entregables
[cite_start]Para cumplir plenamente con los entregables:
 * db.json: Asegúrate de tener un archivo db.json en la raíz de tu proyecto para json-server. Debe incluir al menos un usuario con role: 'admin' para pruebas, y algunos cursos de ejemplo.
   Ejemplo de db.json:
   {
  "users": [
    {
      "id": "1",
      "name": "Admin User",
      "email": "admin@example.com",
      "password": "adminpassword",
      "role": "admin"
    },
    {
      "id": "2",
      "name": "Student User",
      "email": "student@example.com",
      "password": "studentpassword",
      "role": "student"
    }
  ],
  "courses": [
    {
      "id": "101",
      "title": "Introduction to JavaScript",
      "instructor": "John Doe",
      "capacity": 5,
      "enrolled": ["student@example.com"]
    },
    {
      "id": "102",
      "title": "Advanced CSS Techniques",
      "instructor": "Jane Smith",
      "capacity": 3,
      "enrolled": []
    }
  ]
}

 * README.md: Crea un archivo README.md en la raíz de tu repositorio con:
   * [cite_start]Tu nombre completo, clan, correo y documento de identidad.
   * Una descripción del proyecto.
   * [cite_start]Instrucciones claras y detalladas sobre cómo levantar y usar la solución (ej. npm install, npm start, cómo iniciar json-server con tu db.json, cómo acceder a la aplicación en el navegador).
 * Colección POSTMAN: Incluye un archivo de colección de Postman (exportado en formato JSON) en tu repositorio. [cite_start]Debe contener peticiones para probar las operaciones CRUD de users y courses (GET, POST, PUT, DELETE).
 * [cite_start]package.json: Verifica que el name en tu package.json siga el formato nombreapellidoXXX (ej. juanperez123).
 * [cite_start]Comentarios en el código y Commits: Asegúrate de que el código tenga comentarios claros en secciones clave y que tu historial de Git muestre commits descriptivos.
Implementando estos cambios, tu solución se alineará mucho más estrechamente con todos los requisitos y criterios de aceptación del enunciado.
